🧩 STEP-BY-STEP AUTOMATION PLAN
🔹 1. Local Project Structure (Git Repo)
Organize your local repo like this:

arduino
Copy
Edit
mane-flask-app/
├── app/
│   └── app.py
├── Dockerfile
├── requirements.txt
├── buildspec.yml
├── imagedefinitions.json         # generated by CodeBuild
├── cloudformation/
│   ├── network-stack.yml         # VPC, Subnets, IGW, NAT, RTs
│   ├── ecr-stack.yml             # ECR repo
│   ├── ecs-stack.yml             # ECS cluster, task def, service, ALB, ASG
│   └── cicd-stack.yml            # S3, CodeBuild, CodePipeline, roles
└── README.md

🛠️ STEP-BY-STEP DEPLOYMENT FLOW
Here’s the full automated flow:

🔸 Step 1: Infrastructure Setup (IaC)
Run these stacks in this order using AWS CloudFormation Console or CLI.

Deploy network-stack.yml
Creates:

VPC (with tags)

2 Public + 2 Private Subnets

NAT Gateway, IGW

Route tables

Deploy ecr-stack.yml
Creates:

ECR repository

Exports repo name

Deploy ecs-stack.yml
Creates:

ECS Cluster

ALB (Application Load Balancer)

Target group + listener

Task definition

ECS Service (private subnet)

Autoscaling rules

Deploy cicd-stack.yml
Creates:

S3 artifact bucket

CodeBuild project

CodePipeline

IAM roles

Hooks to GitHub

🔸 Step 2: Push Code to GitHub
Push everything to GitHub (you’ve already written app.py, Dockerfile, etc.)

Make sure main branch exists and is configured in the pipeline stack.

🔸 Step 3: Pipeline Triggers
Once everything is deployed:

CodePipeline fetches your GitHub code (OAuth token must be configured).

CodeBuild:

Logs in to ECR

Builds Docker image from Dockerfile

Pushes image to ECR

Creates imagedefinitions.json

ECS service is updated automatically with the new image.

🔸 Step 4: Access Your App
ALB (in public subnet) listens on port 80

Routes to ECS service running in private subnets

Visit: http://<ALB-DNS> → It shows: “Hello from [lastname] ECS Container”

🔐 Security & Best Practices
No public access to ECS containers

ALB exposes only HTTP endpoint

S3 bucket is private

IAM roles are scoped per service (CodeBuild, CodePipeline, ECS)

Artifacts are retained (versioned, lifecycle rules)

# 🚀 Mane Flask App – CI/CD on AWS (ECS Fargate)

This project automates the deployment of a containerized Flask app using AWS services and Infrastructure as Code (IaC) via CloudFormation.

---

## 📦 Tech Stack

- **Flask** – Python Web Framework
- **Docker** – Containerization
- **AWS CloudFormation** – Infrastructure as Code
- **ECS Fargate** – Serverless container orchestration
- **ECR** – Docker image registry
- **ALB** – Application Load Balancer
- **CodePipeline + CodeBuild** – CI/CD automation
- **S3** – Artifact storage
- **GitHub** – Source control and webhook trigger

---

## 🧱 Architecture Overview

1. **VPC Stack** (`network-stack.yml`)  
   - Custom VPC with public/private subnets, IGW, NAT, and routing.

2. **ECR Stack** (`ecr-stack.yml`)  
   - Creates the container image repository for Flask app.

3. **ECS Fargate App Stack** (`ecs-fargate-stack.yml`)  
   - Defines ECS Cluster, Task Definition, Service, and ALB for Flask app.

4. **CI/CD Stack** (`cicd-stack.yml`)  
   - Automates CodePipeline, CodeBuild, artifact bucket, IAM roles.

---

## 🛠️ Prerequisites

- AWS Account and CLI configured
- CloudFormation console access
- GitHub repo with:
  - `Dockerfile`
  - `buildspec.yml`
  - `app.py`
  - `requirements.txt`

---

## 🚀 Deployment Steps

### 1. Deploy CloudFormation Stacks (in order)

Deploy these **one by one** via AWS Console → CloudFormation → *Create stack* → *With new resources*:

#### ✅ 1. Network Stack

```yaml
network-stack.yml
```

Creates your VPC, subnets, NAT, routing.

#### ✅ 2. ECR Stack

```yaml
ecr-stack.yml
```

Creates the container image repository for your app.

#### ✅ 3. ECS Fargate App Stack

```yaml
ecs-fargate-stack.yml
```

Defines ECS Cluster, Task Definition, ALB, Service, etc.

#### ✅ 4. CI/CD Pipeline Stack

```yaml
cicd-stack.yml
```

Creates S3 bucket, CodePipeline, CodeBuild, IAM roles.

---

### 2. Push Code to GitHub

Your repo should contain:

```
📁 your-repo/
 ├ 📄 app.py
 ├ 📄 Dockerfile
 ├ 📄 buildspec.yml
 ┗ 📄 requirements.txt
```

Commit and push the files:

```bash
git add .
git commit -m "Initial deployment"
git push origin main
```

---

### 3. Pipeline Flow

Once you push:

1. **CodePipeline** pulls code from GitHub
2. **CodeBuild** builds the Docker image
3. **Image** is pushed to **ECR**
4. ECS Service is **updated automatically**
5. You can visit the app via the **ALB DNS**

---

## 🥪 Testing

After deployment, get the **ALB DNS Name** from the ECS stack outputs and open it in the browser.

You should see your Flask app running!

---

## 📂 Files You Need in GitHub

### Dockerfile

```dockerfile
FROM python:3.11-slim

WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt
COPY . .

CMD ["python", "app.py"]
```

### buildspec.yml

```yaml
version: 0.2

phases:
  pre_build:
    commands:
      - echo Logging in to Amazon ECR...
      - aws --version
      - $(aws ecr get-login --no-include-email --region $AWS_REGION)
  build:
    commands:
      - echo Building Docker image...
      - docker build -t $ECR_REPOSITORY_NAME .
      - docker tag $ECR_REPOSITORY_NAME:latest $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$ECR_REPOSITORY_NAME:latest
  post_build:
    commands:
      - echo Pushing Docker image...
      - docker push $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$ECR_REPOSITORY_NAME:latest
      - echo Writing image definition...
      - printf '[{"name":"flask-container","imageUri":"%s"}]' $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$ECR_REPOSITORY_NAME:latest > imagedefinitions.json

artifacts:
  files:
    - imagedefinitions.json
```

---

## 👤 Author

**Sachin**  
💬 Built using AWS best practices, serverless Fargate, and fully automated CI/CD.


